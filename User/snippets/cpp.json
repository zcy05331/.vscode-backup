{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Cpp File Module": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define R register",
			"#define ll long long",
			"#define sum(a, b, mod) (((a) + (b)) % mod)",
			"$0",
			"int main()",
			"{   ",
			""
			"    return 0;",
			"}",
			"",
		],
		"description": "A cpp file template."
	},
	"Cpp Read Functions Module": {
		"prefix": "read",
		"body": [
			"inline int read()",
			"{",
			"	int x = 0;",
			"	char ch = getchar();",
			"	while(ch > '9' || ch < '0')"
			"		ch = getchar();"
			"	while(ch <= '9' && ch >= '0') "
			"		x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();"
			"	return x;",
			"}$0",
		],
		"description": "A Read Functions Module."
	},
	"Cpp Read Nagative Intenger Functions Module": {
		"prefix": "readneg",
		"body": [
			"inline int read()",
			"{",
			"	int x = 0, f = 1;",
			"	char ch = getchar();"
			"	while(ch > '9' || ch < '0')",
			"	{",
			"		if(ch == '-')",
			"			f = 0;",
			"		ch = getchar();",
			"	}",
			"	while(ch <= '9' && ch >= '0') ",
			"		x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();",
			"	return f ? x : (-x);",
			"}",
		],
		"description": "A Read Nagative Functions Module."
	},
	"Cpp Fast Multiple Module": {
		"prefix": "fast_mul",
		"body": [
			"inline int fast_mul(int a, int b, int p)",
			"{",
			"    int ans = 0;",
			"    while (b)",
			"    {",
			"        if (b & 1)",
			"            ans = (ans + a) % p;",
			"        a = (a + a) % p;",
			"        b >>= 1;",
			"    }",
			"    return ans;",
			"}",
		],
		"description": "A Fast Multiple Module."
	},
	"Network Flow Module": {
		"prefix": "networkflow",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define R register",
			"#define ll long long",
			"#define cmax(a, b) ((a < b) ? b : a)",
			"#define cmin(a, b) ((a < b) ? a : b)",
			"#define sum(a, b, mod) ((a + b) % mod)",
			"",
			"const int MaxN = 2e4 + 10;",
			"const int MaxM = 5e5 + 10;",
			"const int inf = (1 << 30);",
			"",
			"struct edge",
			"{",
			"    int to, next, cap;",
			"};",
			"",
			"edge e[MaxM];",
			"int head[MaxN], dep[MaxN], cur[MaxN];",
			"int n, m, s = 20000, t = 20001, cnt = 1, ans;",
			"",
			"inline void add(int u, int v, int c)",
			"{",
			"    ++cnt;",
			"    e[cnt].to = v;",
			"    e[cnt].next = head[u];",
			"    e[cnt].cap = c;",
			"    head[u] = cnt;",
			"}",
			"",
			"inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }",
			"",
			"inline int read()",
			"{",
			"    int x = 0;",
			"    char ch = getchar();",
			"    while (ch > '9' || ch < '0')",
			"        ch = getchar();",
			"    while (ch <= '9' && ch >= '0')",
			"        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();",
			"    return x;",
			"}",
			"",
			"inline int bfs()",
			"{",
			"    memset(dep, 0, sizeof(dep));",
			"    memcpy(cur, head, sizeof(head));",
			"    std::queue<int> q;",
			"    dep[s] = 1;",
			"    q.push(s);",
			"    while (!q.empty())",
			"    {",
			"        int u = q.front();",
			"        q.pop();",
			"        for (int i = head[u]; i; i = e[i].next)",
			"        {",
			"            int v = e[i].to, c = e[i].cap;",
			"            if (dep[v] || !c)",
			"                continue;",
			"            dep[v] = dep[u] + 1;",
			"            q.push(v);",
			"        }",
			"    }",
			"    return dep[t];",
			"}",
			"",
			"inline int dinic(int u, int flow)",
			"{",
			"    if (u == t)",
			"        return flow;",
			"    int rest = flow;",
			"    for (int i = cur[u]; i && (flow - rest < flow); i = e[i].next)",
			"    {",
			"        cur[u] = i;",
			"        int v = e[i].to, c = e[i].cap;",
			"        if (dep[v] != dep[u] + 1 || !c)",
			"            continue;",
			"        int k = dinic(v, cmin(rest, c));",
			"        if (!k)",
			"            dep[v] = -1;",
			"        else",
			"        {",
			"            e[i].cap -= k;",
			"            e[i ^ 1].cap += k;",
			"            rest -= k;",
			"        }",
			"    }",
			"    if (flow - rest < flow)",
			"        dep[u] = -1;",
			"    return flow - rest;",
			"}",
			"",
			"inline void solve()",
			"{",
			"    int now = 0;",
			"    while (bfs())",
			"        while ((now = dinic(s, inf)))",
			"            ans += now;",
			"}",
			"",
			"int main()",
			"{",
			"",
			"    return 0;",
			"}",
		],
		"description": "A Network Flow Module."
	},
	"Min Cost Max Flow Module": {
		"prefix": "mincostmaxflow",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define R register",
			"#define ll long long",
			"#define cmax(a, b) ((a < b) ? b : a)",
			"#define cmin(a, b) ((a < b) ? a : b)",
			"#define sum(a, b, mod) ((a + b) % mod)",
			"",
			"const int MaxN = 5e4 + 10;",
			"const int MaxM = 5e5 + 10;",
			"",
			"struct edge",
			"{",
			"    int next, to, flow, cost;",
			"};",
			"",
			"edge e[MaxM];",
			"int n, m, s = 6000, t = 6001, ans, cnt = 1, mincost, maxflow;",
			"int head[MaxN], flow[MaxN], dis[MaxN], pre[MaxN], last[MaxN], vis[MaxN];",
			"",
			"inline void add(int u, int v, int f, int c)",
			"{",
			"    ++cnt;",
			"    e[cnt].to = v;",
			"    e[cnt].flow = f;",
			"    e[cnt].cost = c;",
			"    e[cnt].next = head[u];",
			"    head[u] = cnt;",
			"}",
			"",
			"inline void add_edge(int u, int v, int f, int c)",
			"{",
			"    add(u, v, f, c);",
			"    add(v, u, 0, -c);",
			"}",
			"",
			"inline int read()",
			"{",
			"    int x = 0, f = 1;",
			"    char ch = getchar();",
			"    while (ch > '9' || ch < '0')",
			"    {",
			"        if (ch == '-')",
			"            f = 0;",
			"        ch = getchar();",
			"    }",
			"    while (ch <= '9' && ch >= '0')",
			"        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();",
			"    return f ? x : (-x);",
			"}",
			"",
			"int spfa()",
			"{",
			"    memset(dis, 0x3f, sizeof(dis));",
			"    memset(flow, 0x3f, sizeof(flow));",
			"    memset(vis, 0, sizeof(vis));",
			"    std::queue<int> q;",
			"    q.push(s);",
			"    vis[s] = 1;",
			"    dis[s] = 0;",
			"    pre[t] = -1;",
			"    while (!q.empty())",
			"    {",
			"        int u = q.front();",
			"        q.pop();",
			"        vis[u] = 0;",
			"        for (int i = head[u]; i; i = e[i].next)",
			"        {",
			"            if (e[i].flow && dis[e[i].to] > dis[u] + e[i].cost)",
			"            {",
			"                int v = e[i].to;",
			"                dis[v] = dis[u] + e[i].cost;",
			"                pre[v] = u;",
			"                last[v] = i;",
			"                flow[v] = cmin(flow[u], e[i].flow);",
			"                if (!vis[v])",
			"                {",
			"                    vis[v] = 1;",
			"                    q.push(v);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return pre[t] != -1;",
			"}",
			"",
			"void MCMF()",
			"{",
			"    while (spfa())",
			"    {",
			"        int u = t;",
			"        maxflow += flow[t];",
			"        mincost += flow[t] * dis[t];",
			"        while (u != s)",
			"        {",
			"            e[last[u]].flow -= flow[t];",
			"            e[last[u] ^ 1].flow += flow[t];",
			"            u = pre[u];",
			"        }",
			"    }",
			"}",
			"",
			"int main()",
			"{",
			"",
			"    return 0;",
			"}",
		],
		"description": "A Min Cost Max Flow Module."
	}
}